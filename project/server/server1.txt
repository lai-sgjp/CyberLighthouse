package main

import (
	"bufio"
	"strings"
	//"errors"
	//"net/http"
	"net"//还需要单独导入，因为net包下面还用到了除了http之外的内容
	"fmt"
	"os"
	"log"//需要引入
)

func port() ([]string,error) {
	fmt.Println("Please enter port seperate by space.(e.g.\"8000\" \"8001\" \"8002\")")


	scanner := bufio.NewReader(os.Stdin)//括号里面的参数表示读取源
	//按照格式输入`":port"`
	//我想要检查一下格式?
	//var buf [1000]byte//这里我想更智能一点，不知道多大的缓冲区域才足够?不过似乎垃圾自动回收
	input ,err := scanner.ReadString('\n')//这里返回读取到的字符数//buf[:]只能放在Read()里面，不能放在ReadString里面。后者里面表示读到哪里(不打双引号,打**单引号**！)，前者则是表示全部读取
	if err != nil {
		fmt.Println("read from stdin failed,err:",err)
		log.Fatal(err)
		//return ports,nil
	}
	//去除换行符和空格
	input = strings.TrimSpace(input)
	//使用空格隔开端口
	port := strings.Split(input," ")//这里创建的将会一个切片以供下面进行处理
//########################################
	var ports []string
	//无
	for _,port := range port {
		ports = append(ports,port)
	}//通过append方法添加则可以有效的避开索引的问题
/*这个方法的错误：utf-8每个字符的字节是没办法机器自动得知的，因此index就会失效
	var portSlice []string = make([]string,n)
	var i int 
	for i = 0; i < n; i++ {//for中的初始条件不能进行变量的声明
		portSlice[i] = buf[i]
	}
	return portSlice,nil
	*/return ports,nil
}
	

func option() {//同时使用是如何解决端口等占用
	fmt.Println("Whether the service can support udp or not?(y/n)")
	var choice utune//go中与C中的char类似的是utune
	_,err := fmt.Scanln("%s",&choice)
	if err != nil {
		fmt.Println("Input error!Detail:",err)//之后有时间想将这个写入log？
		log.Fatal(err)
	}
	//choice = strings.ToUpper(choice)//switch中的只能为变量，若要对起进行操作只能先在switch之前进行，否则会报错`too many errora`
	switch  choice{//全部转为大写//里面只能为单个字符或者是整数，不能为其他的比如说字符串
	case 'y':

		portSlice,err :=port()//生命周期在这个语句块
		if err != nil {
			fmt.Println("Failed to get the port")
			log.Fatal("Failed to get the port:",err)
		}

		type ser struct{}//注意这里与C中结构体的不同
		for _,port := range portSlice {
			ser , err := net.ListenUDP("udp",port)//UDP中没有监听的概念
			if err != nil {
				log.Printf("The listen pocess to the ",port,"failed.")
				continue//我想把它输入到日志里面？
			}
		}

		defer ser.Close()
		buf := make([]byte,1024)
		for {
			n,clientAddr,err := ser.ReadFromUDP(buf)
			if err != nil {
				log.Fatal(err)
			}
			
			_,err = ser.WriteToUDP([]byte(buf[:n]),clientAddr)
			if err != nil {
				fmt.Println("Failed to send response:",err)
				log.Fatal("Failed to send response:",err)
			}
		}
	case 'n':
		return
	default:
		fmt.Println("Input error!The server will only support TCP...")
		log.Fatal(err)
	}
}

func pocessTCP(conn net.Conn) {
	defer conn.Close()

	for {
		reader := bufio.NewReader(conn)
		var buf [200000]byte
		n ,err := reader.Read(buf[:])
		
		if err != nil {
			fmt.Println("read from client failed,err:",err)
			log.Fatal(err)
		}

		recvStr := string(buf[:n])
		fmt.Println("Message recieved:",recvStr)
		conn.Write([]byte(recvStr))
		/*
		这里只能有一个表示缓冲区的参数，否则会报错：
		too many arguments in call to conn.Write
        have (string, []byte)
        want ([]byte)
		*/
	}
}//响应过程

func main() {

	option()

	var portSlice []string//函数返回值不能进行声明，但注意可以自动声明的
	portSlice,err :=port()
	if err != nil {
		fmt.Println("Can't get the port ! err:",err)
		log.Fatal("Can't get the port ! err:",err)
	}

	for _,port := range portSlice {
		listen,err := net.Listen("tcp",port)
		if err != nil {
			log.Printf("The listen pocess to the ",port,"failed.")
			continue
		}
	}
	
	for {
		conn , err := listen.Accept()
		if err != nil {
			log.Printf("accept failed,err:", err )
			continue
		}

		go pocessTCP(conn)

	
	}

}